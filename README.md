BLAKE.js
====

Pure Javascript implementation of the BLAKE2b and BLAKE2s hash functions.

BLAKE is the default hash function in the venerable `NaCl` cryptography library. Like SHA2 and SHA3 but unlike MD5 and SHA1, it's believed to be secure. With an optimized assembly implementation, it's faster than all of those.

Of course, this one is Javascript, so it won't be winning any speed records. More on Performance below. It'll be totally fine for most applications though, and it's the only way to compute BLAKE in a browser.

```js
var blake = require('blakejs')
console.log(blake.blake2bHex('abc'))
// prints ba80a53f981c4d0d6a2797b69f12f6e94c212f14685ac4b74b12bb6fdbffa2d17d87c5392aab792dc252d5de4533cc9518d38aa8dbf1925ab92386edd4009923

console.log(blake.blake2sHex('abc'))
// prints 508c5e8c327c14e2e1a72ba34eeb452f37458b209ed63a294d999b4c86675982
```

API
---
First, `blake2b` computes a BLAKE2b hash.

Pass it a `Uint8Array` containing bytes to hash, and it will return a `Uint8Array` containing the hash.

```js
// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a Uint8Array or ASCII string
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
function blake2b(input, key, outlen) {
    [...]
}
```

For convenience, `blake2bHex` takes the same arguments and works the same way, but returns a hex string.

Second, you can use the `blake2b_init`, `blake2bupdate`, and `blake2b_final` functions to compute the hash of a stream of bytes.

```js
var KEY = null // optional key
var OUTPUT_LENGTH = 64 // bytes
var context = blake2b_init(OUTPUT_LENGTH, KEY)
...
// each time you get a byte array from the stream:
blake2b_update(context, bytes)
...
// finally, once the stream has been exhausted
var hash = blake2b_final(context)
// returns a 64-byte hash, as a Uint8Array
```

Finally, all five of these functions (`blake2b`, `blake2bHex`, `blake2b_init`, `blake2b_update`, and `blake2b_final`) have `blake2s` equivalents. The inputs are identical except that maximum key size and maximum output size are 32 bytes instead of 64.

Limitations
---
* Can only handle up to 2**53 bytes of input

Testing
---
* Examples from the RFC
* BLAKE2s self-test from the RFC
* Examples from http://pythonhosted.org/pyblake2/examples.html
* A longer set of test vectors generated by https://github.com/jedisct1/crypto-test-vectors/tree/master/crypto/hash/blake2/blake2b/nosalt-nopersonalization/generators/libsodium

Performance
---
```
BLAKE2b: 15.2 MB / second on a 2.2GHz i7-4770HQ
BLAKE2s: 20 MB / second

¯\_(ツ)_/¯
```

If you're using BLAKE2b in server side code, you probably want the [native wrapper](https://www.npmjs.com/package/blake2) which should be able to do several hundred MB / second on the same processor.

If you're using BLAKE2b in a web app, 15 MB/sec is probably fine.

Javascript doesn't have 64-bit integers, and BLAKE2b is a 64-bit integer algorithm. Writing it with`Uint32Array` is not that fast. BLAKE2s is a 32-bit algorithm, so it's a bit faster.

If we want better machine code at the expense of gross looking JS code, we could use asm.js


License
---
Creative Commons CC0. Ported from the reference C implementation in
[RFC 7693](https://tools.ietf.org/html/rfc7693).
